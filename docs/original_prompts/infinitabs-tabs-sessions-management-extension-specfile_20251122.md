# SPECIFICATION DOCUMENT — “LazyTabs Session Manager”

## 0. Short Summary

* **One browser window = one session.**
* **One session = one bookmark folder.**
* Bookmarks inside that folder = **logical tabs**.
* Subfolders inside that folder = **tab groups**, each with its own logical tabs.
* **Live tabs** = real browser tabs; a small active subset.
* A **vertical sidebar navstrip (side panel)** shows the entire session structure (logical tabs + groups), highlights which ones are live, and mounts/unmounts live tabs.

---

## 1. Overall Architecture

### 1.1 Components

* **Background / service worker script**

  * Maintains in-memory session state.
  * Observes `tabs`, `windows`, `bookmarks` events.
  * Implements logic for sync, session switching, unmount.

* **Sidebar UI (side panel)**

  * HTML + JS page rendered in Chrome side panel.
  * Communicates with background via `chrome.runtime.sendMessage` or `chrome.runtime.connect`.
  * Renders session tree (tabs + groups) and session list.

* **Root session bookmark folder**

  * Dedicated parent folder: `"LazyTabs Sessions"`.
  * Each child folder under it = one session.

### 1.2 Key Invariants

1. Every window is bound to **exactly one** session folder.
2. The **order** of bookmarks and subfolders inside a session folder encodes the logical order.
3. No bookmark titles or URLs are polluted with metadata; they remain user-friendly.
4. All state required for mapping and last active tab, etc., is stored in extension storage, keyed by bookmark IDs and window IDs.

---

## 2. Data Model

Use TypeScript-like notation for clarity. Real code can be JavaScript.

### 2.1 Basic Types

```ts
type SessionId = string;       // same as bookmark folder id for session
type LogicalTabId = string;    // internal GUID for logical tab (in-memory)
type BookmarkId = string;
type WindowId = number;
type TabId = number;
type GroupId = string | null;  // bookmark folder id for group, or null
```

### 2.2 LogicalTab

Represents one logical tab (one bookmark).

```ts
interface LogicalTab {
  logicalId: LogicalTabId;   // generated by extension, not stored in bookmark
  sessionId: SessionId;      // which session folder this belongs to
  bookmarkId: BookmarkId;    // bookmark node id
  url: string;
  title: string;
  groupId: GroupId;          // null = top-level, else bookmark folder id of group
  indexInSession: number;    // position among all logical tabs in session order
  indexInGroup?: number;     // position within group if grouped

  liveTabIds: TabId[];       // all currently open live tabs representing this logical tab
  lastUpdated: number;       // timestamp
}
```

### 2.3 TabGroup

Represents a tab group as a bookmark subfolder.

```ts
interface TabGroup {
  groupId: GroupId;          // bookmark folder id
  sessionId: SessionId;
  title: string;
  indexInSession: number;    // order among top level children in session folder
}
```

### 2.4 Session

```ts
interface Session {
  sessionId: SessionId;        // bookmark folder id
  name: string;                // folder title
  rootFolderId: BookmarkId;    // "LazyTabs Sessions" folder id
  windowId: WindowId | null;   // bound window, or null if detached

  logicalTabs: LogicalTab[];   // ordered by indexInSession
  groups: Record<GroupId, TabGroup>; // groupId -> TabGroup

  lastActiveLogicalTabId?: LogicalTabId;
  lastSynced: number;
}
```

### 2.5 Global Runtime State (background)

```ts
interface GlobalState {
  sessionsById: Record<SessionId, Session>;
  windowToSession: Record<WindowId, SessionId>;
  tabToLogical: Record<TabId, LogicalTabId>;   // live tab -> logical tab
  initialized: boolean;
}
```

This state is held in memory in the background script and persisted in `chrome.storage.local` as needed (for last active logical tab, window -> session mapping, etc.).

---

## 3. Bookmark Structure

### 3.1 Root Folder

On startup:

```ts
async function ensureRootFolder(): Promise<BookmarkId> {
  const existing = await chrome.bookmarks.search({ title: "LazyTabs Sessions" });
  const folder = existing.find(n => n.title === "LazyTabs Sessions" && !n.url);
  if (folder) return folder.id;
  const created = await chrome.bookmarks.create({ title: "LazyTabs Sessions" });
  return created.id;
}
```

All sessions live as direct subfolders of `"LazyTabs Sessions"`.

### 3.2 Session Folder

Each session is a bookmark folder under root:

```text
LazyTabs Sessions
├── Work Session 1 (folder, = SessionId)
│   ├── Bookmark: Logical Tab 1
│   ├── Bookmark: Logical Tab 2
│   ├── Folder: Group A
│   │   ├── Bookmark: Logical Tab A1
│   │   └── Bookmark: Logical Tab A2
│   └── Folder: Group B
│       ├── Bookmark: Logical Tab B1
│       └── Bookmark: Logical Tab B2
└── Music Session (folder, = SessionId)
    ├── Bookmark: Logical Tab M1
    └── Folder: Group C
        ├── Bookmark: Logical Tab C1
        └── Bookmark: Logical Tab C2
```

Rules:

* Direct children of a session folder are either:

  * **Bookmarks** → top-level logical tabs.
  * **Folders** → tab groups.
* Folders under groups are not allowed (no third level).

---

## 4. Runtime Mapping and Reconstruction

### 4.1 Reconstructing a Session from Bookmarks

On binding a window to a session:

```ts
async function loadSessionFromBookmarks(sessionId: SessionId): Promise<Session> {
  const sessionFolder = await chrome.bookmarks.getSubTree(sessionId);
  const children = sessionFolder[0].children || [];

  const logicalTabs: LogicalTab[] = [];
  const groups: Record<GroupId, TabGroup> = {};

  let index = 0;
  for (const child of children) {
    if (child.url) {
      // direct bookmark = top-level logical tab
      logicalTabs.push({
        logicalId: generateGuid(),
        sessionId,
        bookmarkId: child.id,
        url: child.url,
        title: child.title,
        groupId: null,
        indexInSession: index++,
        liveTabIds: [],
        lastUpdated: Date.now(),
      });
    } else {
      // folder = group
      const groupId: GroupId = child.id;
      groups[groupId] = {
        groupId,
        sessionId,
        title: child.title,
        indexInSession: index++,
      };

      const groupChildren = child.children || [];
      for (let j = 0; j < groupChildren.length; j++) {
        const gChild = groupChildren[j];
        if (!gChild.url) continue; // ignore nested folders
        logicalTabs.push({
          logicalId: generateGuid(),
          sessionId,
          bookmarkId: gChild.id,
          url: gChild.url,
          title: gChild.title,
          groupId,
          indexInSession: index++,   // flattened session order
          indexInGroup: j,
          liveTabIds: [],
          lastUpdated: Date.now(),
        });
      }
    }
  }

  return {
    sessionId,
    name: sessionFolder[0].title,
    rootFolderId: sessionFolder[0].parentId!,
    windowId: null,
    logicalTabs,
    groups,
    lastSynced: Date.now(),
  };
}
```

The `indexInSession` is a single flattened ordering of all logical tabs, interleaving top-level and group tabs in the order they appear in the bookmark tree.

---

## 5. Sidebar UI Specification

### 5.1 Layout

`sidebar.html`:

* Header:

  * Session selector (dropdown or list button).
  * Action button: “Unmount all live tabs except this one/selected”.
  * Optional: toggle “Show only live tabs”.

* Main list:

  * For current session:

    * Render items in order of `indexInSession`.
    * For each item:

      * If `groupId === null`: top-level tab row.
      * If representing a group (TabGroup): group header row.
      * If tab with groupId: indented row under its group.

Visual indicators:

* Live tabs: bold title or colored dot.
* Selected tab in sidebar: highlight row.

### 5.2 Messages Between Sidebar and Background

Define a simple message protocol, for example:

```ts
type SidebarToBgMessage =
  | { type: "GET_CURRENT_SESSION_STATE"; windowId: WindowId }
  | { type: "FOCUS_OR_MOUNT_TAB"; logicalId: LogicalTabId }
  | { type: "UNMOUNT_ALL_EXCEPT"; logicalIdsToKeep: LogicalTabId[] }
  | { type: "SWITCH_SESSION"; sessionId: SessionId }
  | { type: "GET_SESSION_LIST" };

type BgToSidebarMessage =
  | { type: "SESSION_STATE"; session: Session }
  | { type: "SESSION_LIST"; sessions: { sessionId: SessionId; name: string }[] }
  | { type: "STATE_UPDATED"; session: Session };
```

The sidebar:

* On load, sends `GET_CURRENT_SESSION_STATE`.
* Subscribes to `STATE_UPDATED` messages to rerender.

---

## 6. Tab & Bookmark Synchronization

The background script listens to `chrome.tabs` and `chrome.windows` events and keeps bookmarks in sync.

### 6.1 Binding a Window to a Session

When a window is created or on user explicit session switch:

```ts
async function bindWindowToSession(windowId: WindowId, sessionId: SessionId) {
  const session = await loadSessionFromBookmarks(sessionId);
  session.windowId = windowId;
  state.sessionsById[sessionId] = session;
  state.windowToSession[windowId] = sessionId;
  await persistWindowSessionMapping();

  await syncExistingTabsInWindowToSession(windowId, sessionId);
  notifySidebarStateUpdated(windowId, sessionId);
}
```

`syncExistingTabsInWindowToSession` maps current live tabs (by URL and position) to logical tabs, creating new logical tabs if necessary.

### 6.2 Mapping Live Tabs to Logical Tabs

At run time:

```ts
function attachLiveTabToLogical(tab: chrome.tabs.Tab, logical: LogicalTab) {
  state.tabToLogical[tab.id] = logical.logicalId;
  if (!logical.liveTabIds.includes(tab.id)) {
    logical.liveTabIds.push(tab.id);
  }
}
```

---

### 6.3 Tabs.onCreated

When a new tab appears in a window that is bound to a session:

```ts
chrome.tabs.onCreated.addListener(async (tab) => {
  const windowId = tab.windowId!;
  const sessionId = state.windowToSession[windowId];
  if (!sessionId) return;

  const session = state.sessionsById[sessionId];

  // Decide group based on tab.groupId / tab.pinned if needed in the future.
  const groupId: GroupId = null; // Phase 1: ignore group unless you use Chrome tab groups API.

  const insertIndex = tab.index; // position among live tabs
  // For phase 1: approximate indexInSession as the same as live tab index,
  // or refine later based on existing logicalTabs and reordering rules.

  const createdBookmark = await chrome.bookmarks.create({
    parentId: groupId ? groupId : session.sessionId,
    title: tab.title || "(loading...)",
    url: tab.url || "about:blank",
  });

  const logical: LogicalTab = {
    logicalId: generateGuid(),
    sessionId,
    bookmarkId: createdBookmark.id,
    url: tab.url || "about:blank",
    title: tab.title || "(loading...)",
    groupId,
    indexInSession: computeIndexInSessionForNewTab(session, insertIndex, groupId),
    liveTabIds: [],
    lastUpdated: Date.now(),
  };

  // Insert logical in session.logicalTabs with correct indexInSession
  insertLogicalTabInOrder(session, logical);
  attachLiveTabToLogical(tab, logical);

  notifySidebarStateUpdated(windowId, sessionId);
});
```

(`computeIndexInSessionForNewTab` and `insertLogicalTabInOrder` encapsulate your ordering rules.)

---

### 6.4 Tabs.onUpdated (URL or title change)

```ts
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  const logicalId = state.tabToLogical[tabId];
  if (!logicalId) return;

  const session = getSessionForTab(tabId);
  const logical = findLogicalTab(session, logicalId);
  let changed = false;

  if (changeInfo.url && changeInfo.url !== logical.url) {
    logical.url = changeInfo.url;
    changed = true;
  }
  if (changeInfo.title && changeInfo.title !== logical.title) {
    logical.title = changeInfo.title;
    changed = true;
  }

  if (changed) {
    logical.lastUpdated = Date.now();
    chrome.bookmarks.update(logical.bookmarkId, {
      title: logical.title,
      url: logical.url,
    });
    notifySidebarStateUpdated(tab.windowId!, session.sessionId);
  }
});
```

---

### 6.5 Tabs.onMoved (reordering live tabs)

Here the heuristic must approximate a full logical reorder using only partial information from live tabs.

High-level algorithm:

```ts
chrome.tabs.onMoved.addListener((tabId, moveInfo) => {
  const logicalId = state.tabToLogical[tabId];
  if (!logicalId) return;

  const windowId = moveInfo.windowId;
  const sessionId = state.windowToSession[windowId];
  if (!sessionId) return;
  const session = state.sessionsById[sessionId];

  // Get the live tabs in their new order
  chrome.tabs.query({ windowId }, (tabs) => {
    const liveOrderLogicalIds: LogicalTabId[] = [];
    for (const t of tabs) {
      const lid = state.tabToLogical[t.id];
      if (lid) liveOrderLogicalIds.push(lid);
    }

    // We now know the relative order between live logical tabs.
    // Reorder session.logicalTabs so that:
    // - Live logical tabs appear in the same relative order as liveOrderLogicalIds.
    // - Non-live logical tabs keep their relative order but are slotted around.

    reorderLogicalTabsBasedOnLiveOrder(session, liveOrderLogicalIds);
    reflectNewLogicalOrderToBookmarks(session);
    notifySidebarStateUpdated(windowId, sessionId);
  });
});
```

`reorderLogicalTabsBasedOnLiveOrder` should implement the rule:

* For each pair of adjacent live logical tabs in `liveOrderLogicalIds`, ensure that in `session.logicalTabs` the second appears **right after** the first (others may be between but should be shifted minimally).
* In the concrete example you gave, this should produce `giraffe, cat, bird, dog, fish` when live order becomes `giraffe, cat, dog`.

Implementation can be greedy: iterate over `liveOrderLogicalIds` and update `indexInSession`.

---

### 6.6 Group Membership Changes

When you start using tab groups (or similar in Chrome):

* On change of tab’s group (for example from Chrome tab group API if used):

  * Move the logical tab bookmark to the corresponding session subfolder (or out to the session folder).
  * Update `logical.groupId` accordingly.
  * Update `indexInSession` respecting the overall ordering.

This can be layered on top of the existing `onMoved` logic.

---

### 6.7 Tabs.onRemoved (closing live tabs)

```ts
chrome.tabs.onRemoved.addListener((tabId, removeInfo) => {
  const logicalId = state.tabToLogical[tabId];
  if (!logicalId) return;

  delete state.tabToLogical[tabId];

  const sessionId = state.windowToSession[removeInfo.windowId];
  if (!sessionId) return;
  const session = state.sessionsById[sessionId];
  const logical = findLogicalTab(session, logicalId);
  if (!logical) return;

  logical.liveTabIds = logical.liveTabIds.filter(id => id !== tabId);

  // Default: keep bookmark (logical tab persists).
  // If later a setting indicates "closing live tab deletes logical tab", then:
  //   - Remove logicalTab from session.logicalTabs
  //   - Delete bookmark via chrome.bookmarks.remove(logical.bookmarkId)

  notifySidebarStateUpdated(removeInfo.windowId, sessionId);
});
```

---

## 7. Manual Unmount Operation

From sidebar, user triggers an action:

* “Unmount all live tabs except this one”
* Or “Unmount all live tabs except selected ones”

Sidebar sends:

```ts
{ type: "UNMOUNT_ALL_EXCEPT", logicalIdsToKeep: LogicalTabId[] }
```

Background handler:

```ts
async function handleUnmountAllExcept(windowId: WindowId, logicalIdsToKeep: LogicalTabId[]) {
  const sessionId = state.windowToSession[windowId];
  if (!sessionId) return;
  const session = state.sessionsById[sessionId];

  const keepSet = new Set(logicalIdsToKeep);

  for (const lt of session.logicalTabs) {
    if (!lt.liveTabIds.length) continue;
    const shouldKeep = keepSet.has(lt.logicalId);
    if (shouldKeep) continue;

    for (const tabId of lt.liveTabIds) {
      try {
        await chrome.tabs.remove(tabId);
      } catch {}
      delete state.tabToLogical[tabId];
    }
    lt.liveTabIds = [];
  }

  notifySidebarStateUpdated(windowId, sessionId);
}
```

Logical tabs (bookmarks) remain untouched.

---

## 8. Sessions Listing and Switching

Sidebar requests list of sessions:

```ts
{ type: "GET_SESSION_LIST" }
```

Background:

```ts
async function getSessionList(): Promise<{sessionId: SessionId; name: string}[]> {
  const rootId = await ensureRootFolder();
  const children = await chrome.bookmarks.getChildren(rootId);
  return children
    .filter(node => !node.url)
    .map(folder => ({ sessionId: folder.id, name: folder.title }));
}
```

Sidebar shows this list and, on selection:

```ts
{ type: "SWITCH_SESSION", sessionId: SessionId }
```

Background:

```ts
async function handleSwitchSession(windowId: WindowId, newSessionId: SessionId) {
  const oldSessionId = state.windowToSession[windowId];
  if (oldSessionId) {
    // Unmount all live tabs in old session
    const oldSession = state.sessionsById[oldSessionId];
    for (const lt of oldSession.logicalTabs) {
      for (const tabId of lt.liveTabIds) {
        try { await chrome.tabs.remove(tabId); } catch {}
        delete state.tabToLogical[tabId];
      }
      lt.liveTabIds = [];
    }
  }

  await bindWindowToSession(windowId, newSessionId);

  // Optionally mount last active logical tab from new session
  const newSession = state.sessionsById[newSessionId];
  if (newSession.lastActiveLogicalTabId) {
    await focusOrMountLogicalTab(windowId, newSessionId, newSession.lastActiveLogicalTabId);
  }

  notifySidebarStateUpdated(windowId, newSessionId);
}
```

`focusOrMountLogicalTab` is the shared function used for sidebar clicks:

```ts
async function focusOrMountLogicalTab(windowId: WindowId, sessionId: SessionId, logicalId: LogicalTabId) {
  const session = state.sessionsById[sessionId];
  const logical = findLogicalTab(session, logicalId);
  if (!logical) return;

  if (logical.liveTabIds.length > 0) {
    await chrome.tabs.update(logical.liveTabIds[0], { active: true });
    await chrome.windows.update(windowId, { focused: true });
  } else {
    const created = await chrome.tabs.create({ windowId, url: logical.url, active: true });
    attachLiveTabToLogical(created, logical);
  }

  session.lastActiveLogicalTabId = logicalId;
  notifySidebarStateUpdated(windowId, sessionId);
}
```

---

## 9. Hooks for Future Automatic Tabs Suspender

Design notes for later integration (no implementation in phase 1):

* Provide a small module interface like:

```ts
interface SuspenderHook {
  onIdleLiveTab(tabId: TabId, logical: LogicalTab, session: Session): Promise<void>;
}
```

* The core logic should call this hook when a tab is considered idle (in the future), for example:

```ts
if (suspender && isTabIdle(tabId)) {
  await suspender.onIdleLiveTab(tabId, logical, session);
}
```

* The default behavior now can be no-op, but the interface exists so that a future suspender can:

  * Ensure bookmark/logicalTab is up to date.
  * Close the real tab.
  * Possibly store extra metadata.

The current architecture already supports this: closing a live tab while preserving the logical tab is just an unmount, which the suspender would perform automatically.

---

## 10. Chrome MV3 Implementation Notes (Summary)

* `manifest.json`:

  * `"manifest_version": 3`
  * `"permissions": ["tabs", "bookmarks", "windows", "storage", "sidePanel"]`
  * `"background": { "service_worker": "background.js" }`
  * `"side_panel": { "default_path": "sidebar.html" }`

* `background.js`:

  * Implements all state, event listeners, and logic above.

* `sidebar.html` + `sidebar.js`:

  * Renders session list and logical tabs.
  * Sends messages to background.
  * Receives state snapshots and updates.
